variabname: 'Stan'
scopeName: 'source.stan'
fileTypes: [
  'stan'
  'stanfuncs'
]
patterns: [
  {
    include: '#program'
  }
  {
    comment: 'need to put function declaration before variable declaration'
    include: '#function-declarations'
  }
  {
    include: '#variable-declarations'
  }
  {
    include: '#statements'
  }
]
repository:
  docblock:
    patterns: [
      {
        match: '(?<!\\w)@(param|return)\\b'
        name: 'storage.type.class.standoc'
      }
    ]
  comments:
    patterns: [
      {
        begin: '^\\s*((#)\\s*(include))\\b\\s*'
        end: '\\s*(?=(?://|/\\*|#)|\\n|$)'
        beginCaptures:
          '1':
            name: 'keyword.control.directive.include.stan'
          '2':
            name: 'punctuation.definition.directive.stan'
          '4':
            name: 'string.quoted.other.include.stan'
        name: 'meta.preprocessor.include.stan'
        patterns: [
          {
            begin: '"'
            beginCaptures:
              '0':
                name: 'punctuation.definition.string.begin.stan'
            end: '"'
            endCaptures:
              '0':
                name: 'punctuation.definition.string.end.stan'
            name: 'string.quoted.double.include.stan'
          }
          {
            begin: '<'
            beginCaptures:
              '0':
                name: 'punctuation.definition.string.begin.stan'
            end: '>'
            endCaptures:
              '0':
                name: 'punctuation.definition.string.end.stan'
            name: 'string.quoted.other.lt-gt.include.stan'
          }
          {
            begin: '\''
            beginCaptures:
              '0':
                name: 'punctuation.definition.string.begin.stan'
            end: '\''
            endCaptures:
              '0':
                name: 'punctuation.definition.string.end.stan'
            name: 'string.quoted.single.include.stan'
          }
          {
            match: '.+'
            name: 'string.quoted.other.noquote.include.stan'
          }
        ]
      }
      {
        begin: '/\\*\\*(?!/)'
        captures:
          '0':
            name: 'punctuation.definition.comment.stan'
        patterns: [
          {
            include: '#docblock'
          }
        ]
        end: '\\*/'
        name: 'comment.block.documentation.stan'
      }
      {
        comment: '/* comment block */'
        begin: '/\\*'
        beginCaptures:
          '0':
            name: 'punctuation.definition.comment.stan'
        end: '\\*/'
        endCaptures:
          '0':
            name: 'punctuation.definition.comment.stan'
        name: 'comment.block.stan'
      }
      {
        comment: '// comment'
        begin: '//'
        beginCaptures:
          '0':
            name: 'punctuation.definition.comment.stan'
        end: '\\n'
        name: 'comment.line.double-slash.stan'
      }
      {
        comment: '# comment'
        begin: '#'
        beginCaptures:
          '0':
            name: 'punctuation.definition.comment.stan'
        end: '\\n'
        name: 'comment.line.number-sign.stan'
      }
    ]
  strings:
    patterns: [
      {
        comment: 'string literal'
        begin: '\"'
        beginCaptures:
          '0':
            name: 'punctuation.definition.string.begin.stan'
        end: '\"'
        endCaptures:
          '0':
            name: 'punctuation.definition.string.end.stan'
        name: 'string.quoted.double.stan'
        patterns: [
          {
            comment: 'Stan strings can only contain ASCII printable characters'
            match: '[^ a-zA-Z0-9~@#$%^&*_\'`\\-+={}\\[\\]()<>|/!?.,;:"]+'
            name: 'invalid.illegal.string.stan'
          }
        ]
      }
    ]
  numbers:
    patterns: [
      {
        match: '''
          (?x)
          (
          [0-9]+\\.[0-9]*([eE][+-]?[0-9]+)?
          |
          \\.[0-9]+([eE][+-]?[0-9]+)?
          |
          [0-9]+[eE][+-]?[0-9]+
          )
        '''
        name: 'constant.numeric.real.stan'
      }
      {
        match: '[0-9]+(?=[^A-Za-z_])'
        name: 'constant.numeric.integer.stan'
      }
    ]
  'illegal-identifier':
    comment: "This pattern needs to go before \#identifier to work"
    patterns: [
      {
        match: '\\b([a-zA-Z0-9_]*__|[0-9_][A-Za-z0-9_]+|_)\\b'
        name: 'invalid.illegal.variable.stan'
      }
    ]
  identifier:
    patterns: [
      {
        match: '\\b[A-Za-z][0-9A-Za-z_]*\\b'
        comment: 'generic variable names'
        name: 'meta.identifier.stan'
      }
    ]
  operators1:
    comment: 'Prefix and infix operators usable in range-constraints'
    patterns: [
      {
        match: '!'
        name: 'keyword.operator.logical.stan'
      }
      {
        match: '\\+|-|\\.?\\*|\\.?/|%|\\\\|\\^|\''
        name: 'keyword.operator.arithmetic.stan'
      }
    ]
  'ternary-operator':
    patterns: [
      {
        begin: '\\?'
        beginCaptures:
          '0':
            name: 'keyword.operator.ternary.stan'
        # safety (end this at the end of a statement/expression)
        end: '(:)|(?=(?:[,;)\\]}]|\\b(?:if|else|for|while)\\b))'
        endCaptures:
          '1':
            name: 'keyword.operator.ternary.stan'
        patterns: [
          {
            include: '#expression'
          }
        ]
      }
    ]
  operators2:
    comments: 'Infix and prefix operators not usable in range-constraints'
    patterns: [
      {
        match: '[|][|]|&&'
        name: 'keyword.operator.logical.stan'
      }
      {
        match: '==|!=|<=?|>=?'
        name: 'keyword.operator.logical.stan'
      }
    ]

  'builtin-functions':
    patterns: [
      {
        match: '\\b([A-Za-z0-9][A-Za-z0-9_]*_log|get_lp|if_else|increment_log_prob|integrate_ode|lkj_cov)\\b'
        name: 'invalid.deprecated.function.stan'
      }
      {
        match: '\\b(Phi|Phi_approx|abs|acos|acosh|algebra_solver|append_array|append_col|append_row|asin|asinh|atan|atan2|atanh|bernoulli_cdf|bernoulli_lccdf|bernoulli_lcdf|bernoulli_logit_lpmf|bernoulli_logit_rng|bernoulli_lpmf|bernoulli_rng|bessel_first_kind|bessel_second_kind|beta_binomial_cdf|beta_binomial_lccdf|beta_binomial_lcdf|beta_binomial_lpmf|beta_binomial_rng|beta_cdf|beta_lccdf|beta_lcdf|beta_lpdf|beta_rng|binary_log_loss|binomial_cdf|binomial_coefficient_log|binomial_lccdf|binomial_lcdf|binomial_logit_lpmf|binomial_lpmf|binomial_rng|block|categorical_logit_lpmf|categorical_logit_rng|categorical_lpmf|categorical_rng|cauchy_cdf|cauchy_lccdf|cauchy_lcdf|cauchy_lpdf|cauchy_rng|cbrt|ceil|chi_square_cdf|chi_square_lccdf|chi_square_lcdf|chi_square_lpdf|chi_square_rng|cholesky_decompose|choose|col|cols|columns_dot_product|columns_dot_self|cos|cosh|cov_exp_quad|crossprod|csr_extract_u|csr_extract_v|csr_extract_w|csr_matrix_times_vector|csr_to_dense_matrix|cumulative_sum|determinant|diag_matrix|diag_post_multiply|diag_pre_multiply|diagonal|digamma|dims|dirichlet_lpdf|dirichlet_rng|distance|dot_product|dot_self|double_exponential_cdf|double_exponential_lccdf|double_exponential_lcdf|double_exponential_lpdf|double_exponential_rng|e|eigenvalues_sym|eigenvectors_sym|erf|erfc|exp|exp2|exp_mod_normal_cdf|exp_mod_normal_lccdf|exp_mod_normal_lcdf|exp_mod_normal_lpdf|exp_mod_normal_rng|expm1|exponential_cdf|exponential_lccdf|exponential_lcdf|exponential_lpdf|exponential_rng|fabs|falling_factorial|fdim|floor|fma|fmax|fmin|fmod|frechet_cdf|frechet_lccdf|frechet_lcdf|frechet_lpdf|frechet_rng|gamma_cdf|gamma_lccdf|gamma_lcdf|gamma_lpdf|gamma_p|gamma_q|gamma_rng|gaussian_dlm_obs_lpdf|get_lp|gumbel_cdf|gumbel_lccdf|gumbel_lcdf|gumbel_lpdf|gumbel_rng|head|hypergeometric_lpmf|hypergeometric_rng|hypot|inc_beta|int_step|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|inv|inv_Phi|inv_chi_square_cdf|inv_chi_square_lccdf|inv_chi_square_lcdf|inv_chi_square_lpdf|inv_chi_square_rng|inv_cloglog|inv_gamma_cdf|inv_gamma_lccdf|inv_gamma_lcdf|inv_gamma_lpdf|inv_gamma_rng|inv_logit|inv_sqrt|inv_square|inv_wishart_lpdf|inv_wishart_rng|inverse|inverse_spd|is_inf|is_nan|lbeta|lchoose|lgamma|lkj_corr_cholesky_lpdf|lkj_corr_cholesky_rng|lkj_corr_lpdf|lkj_corr_rng|lmgamma|lmultiply|log|log10|log1m|log1m_exp|log1m_inv_logit|log1p|log1p_exp|log2|log_determinant|log_diff_exp|log_falling_factorial|log_inv_logit|log_mix|log_rising_factorial|log_softmax|log_sum_exp|logistic_cdf|logistic_lccdf|logistic_lcdf|logistic_lpdf|logistic_rng|logit|lognormal_cdf|lognormal_lccdf|lognormal_lcdf|lognormal_lpdf|lognormal_rng|machine_precision|matrix_exp|max|mdivide_left_spd|mdivide_left_tri_low|mdivide_right_spd|mdivide_right_tri_low|mean|min|modified_bessel_first_kind|modified_bessel_second_kind|multi_gp_cholesky_lpdf|multi_gp_lpdf|multi_normal_cholesky_lpdf|multi_normal_cholesky_rng|multi_normal_lpdf|multi_normal_prec_lpdf|multi_normal_rng|multi_student_t_lpdf|multi_student_t_rng|multinomial_lpmf|multinomial_rng|multiply_log|multiply_lower_tri_self_transpose|neg_binomial_2_cdf|neg_binomial_2_lccdf|neg_binomial_2_lcdf|neg_binomial_2_log_lpmf|neg_binomial_2_log_rng|neg_binomial_2_lpmf|neg_binomial_2_rng|neg_binomial_cdf|neg_binomial_lccdf|neg_binomial_lcdf|neg_binomial_lpmf|neg_binomial_rng|negative_infinity|normal_cdf|normal_lccdf|normal_lcdf|normal_lpdf|normal_rng|not_a_number|num_elements|ordered_logistic_lpmf|ordered_logistic_rng|owens_t|pareto_cdf|pareto_lccdf|pareto_lcdf|pareto_lpdf|pareto_rng|pareto_type_2_cdf|pareto_type_2_lccdf|pareto_type_2_lcdf|pareto_type_2_lpdf|pareto_type_2_rng|pi|poisson_cdf|poisson_lccdf|poisson_lcdf|poisson_log_lpmf|poisson_log_rng|poisson_lpmf|poisson_rng|positive_infinity|pow|prod|qr_Q|qr_R|quad_form|quad_form_diag|quad_form_sym|rank|rayleigh_cdf|rayleigh_lccdf|rayleigh_lcdf|rayleigh_lpdf|rayleigh_rng|rep_array|rep_matrix|rep_row_vector|rep_vector|rising_factorial|round|row|rows|rows_dot_product|rows_dot_self|scaled_inv_chi_square_cdf|scaled_inv_chi_square_lccdf|scaled_inv_chi_square_lcdf|scaled_inv_chi_square_lpdf|scaled_inv_chi_square_rng|sd|segment|sin|singular_values|sinh|size|skew_normal_cdf|skew_normal_lccdf|skew_normal_lcdf|skew_normal_lpdf|skew_normal_rng|softmax|sort_asc|sort_desc|sort_indices_asc|sort_indices_desc|sqrt|sqrt2|square|squared_distance|step|student_t_cdf|student_t_lccdf|student_t_lcdf|student_t_lpdf|student_t_rng|sub_col|sub_row|sum|tail|tan|tanh|target|tcrossprod|tgamma|to_array_1d|to_array_2d|to_matrix|to_row_vector|to_vector|trace|trace_gen_quad_form|trace_quad_form|trigamma|trunc|uniform_cdf|uniform_lccdf|uniform_lcdf|uniform_lpdf|uniform_rng|variance|von_mises_lpdf|von_mises_rng|weibull_cdf|weibull_lccdf|weibull_lcdf|weibull_lpdf|weibull_rng|wiener_lpdf|wishart_lpdf|wishart_rng)\\b'
        name: 'support.function.function.stan'
      }
    ]
  reserved:
    patterns: [
      {
        match: '\\b(alignas|alignof|and|and_eq|asm|auto|bitand|bitor|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|false|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|noexcept|not|not_eq|nullptr|operator|or|or_eq|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|true|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while|xor|xor_eq)\\b'
        name: 'invalid.illegal.reserved.stan'
        comment: 'reserved words in C++ that are invalid in Stan'
      }
      {
        match: '\\b(for|in|while|repeat|until|if|then|else|true|false|var|fvar|STAN_MAJOR|STAN_MINOR|STAN_PATCH|STAN_MATH_MAJOR|STAN_MATH_MINOR|STAN_MATH_PATCH)\\b'
        name: 'invalid.illegal.reserved.stan'
        comment: 'Words reserved for internal Stan use'
      }
    ]
  bar:
    patterns: [
      {
        match: '[|]'
        name: 'punctuation.delimiter.bar.stan'
      }
    ]
  arguments:
    patterns: [
      {
        begin: '\\('
        beginCaptures:
          '0':
            name: 'punctuation.definition.arguments.begin.bracket.round.stan'
        end: '\\)'
        endCaptures:
          '0':
            name: 'punctuation.definition.arguments.end.bracket.round.stan'
        name: 'meta.arguments.stan'
        patterns: [
          {
            'include': '#comma'
          }
          {
            'include': '#bar'
          }
          {
            'include': '#expression'
          }
        ]
      }
    ]
  function_calls:
    patterns: [
      {
        # functionCall(arg1,)
        begin: '([A-Za-z][A-Za-z0-9_]*)\\s*(?=\\()'
        beginCaptures:
          '1':
            patterns: [
              {
                include: '#builtin-functions'
              }
              {
                match: "[A-Za-z][A-Za-z0-9_]*"
                name: 'meta.identifier.stan'
              }
            ]
        end: '(?<=\\))'
        name: 'meta.function-call.stan'
        patterns: [
          {
            include: '#arguments'
          }
        ]
      }
    ]
  colon:
    patterns: [
      {
        match: ':'
        name: 'keyword.operator.colon.stan'
      }
    ]
  comma:
    patterns: [
      {
        match: ','
        name: 'punctuation.delimiter.comma.stan'
      }
    ]
  arrays:
    patterns: [
      {
        comment: '{a, b} Array. This is hard to distinguish from a block statement'
        begin: '\\{'
        beginCaptures:
          '0':
            'name': 'punctuation.section.array.begin.bracket.curly.stan'
        end: '\\}'
        endCaptures:
          '0':
            name: 'punctuation.section.array.end.bracket.curly.stan'
        patterns: [
          {
            include: '#comma'
          }
          {
            include: '#expression'
          }
        ]
      }
    ]
  brackets:
    patterns: [
      {
        comment: "[...]"
        begin: '\\['
        beginCaptures:
          '0':
            'name': 'punctuation.section.brackets.begin.bracket.square.stan'
        end: '\\]'
        endCaptures:
          '0':
            name: 'punctuation.section.brackets.end.bracket.square.stan'
        patterns: [
          {
            include: '#comma'
          }
          {
            include: '#colon'
          }
          {
            include: '#expression'
          }
        ]
      }
    ]
  parens:
    patterns: [
      {
        comment: "(...)"
        begin: '\\('
        beginCaptures:
          '0':
            'name': 'punctuation.section.parens.begin.bracket.round.stan'
        end: '\\)'
        endCaptures:
          '0':
            name: 'punctuation.section.parens.end.bracket.round.stan'
        patterns: [
            {
              include: '#expression'
            }
          ]
      }
    ]
  'expression-base':
    comment: 'Patterns for expressions anywhere (including in range-constraints)'
    patterns: [
      {
        include: '#comments'
      }
      {
        include: '#numbers'
      }
      {
        comment: 'function calls needs to go before identifier and parens'
        include: '#function_calls'
      }
      {
        comment: 'This rule needs to preceed identifier to work'
        include: '#illegal-identifier'
      }
      {
        include: '#identifier'
      }
      {
        include: '#operators1'
      }
      {
        include: '#brackets'
      }
      {
        include: '#arrays'
      }
      {
        include: '#parens'
      }
    ]
  'expression':
    comment: 'General expression patterns (outside of range frames)'
    patterns: [
      {
        include: '#expression-base'
      }
      {
        include: '#operators2'
      }
      {
        include: '#ternary-operator'
      }
    ]

  # START of statement patterns ------------------------------
  semicolon:
    patterns: [
      {
        match: ';'
        name: 'punctuation.terminator.statement.stan'
      }
    ]
  'assignment-operators':
    patterns: [
      {
        'match': '(<-|[.]?\\*=|[.]?/=|[+-]?=)'
        'name': 'keyword.operator.assignment.stan'
      }
    ]
  truncation:
    patterns: [
        {
          comment: 'truncation operator T[]'
          begin: '\\b(T)\\s*(\\[)'
          beginCaptures:
            '1':
               name: 'keyword.other.truncation.stan'
            '2':
              name: 'punctuation.defintion.begin.truncation.backets.square.stan'
          end: '\\]'
          endCaptures:
            '0':
              name: 'punctuation.defintion.end.truncation.backets.square.stan'
          patterns: [
            {
              'include': '#comma'
            }
            {
              'include': '#expression'
            }
          ]
        }

      ]
  'builtin-distributions':
    patterns: [
      {
        match: '(bernoulli|bernoulli_logit|beta|beta_binomial|binomial|binomial_logit|categorical|categorical_logit|cauchy|chi_square|dirichlet|double_exponential|exp_mod_normal|exponential|frechet|gamma|gaussian_dlm_obs|gumbel|hypergeometric|inv_chi_square|inv_gamma|inv_wishart|lkj_corr|lkj_corr_cholesky|logistic|lognormal|multi_gp|multi_gp_cholesky|multi_normal|multi_normal_cholesky|multi_normal_prec|multi_student_t|multinomial|neg_binomial|neg_binomial_2|neg_binomial_2_log|normal|ordered_logistic|pareto|pareto_type_2|poisson|poisson_log|rayleigh|scaled_inv_chi_square|skew_normal|student_t|uniform|von_mises|weibull|wiener|wishart)\\b'
        name: 'support.function.distribution.stan'
      }
    ]
  distribution_calls:
    patterns: [
      {
        begin: '([A-Za-z][A-Za-z0-9_]*)\\s*(?=\\()'
        beginCaptures:
          '1':
            patterns: [
              {
                include: '#builtin-distributions'
              }
              {
                match: '[A-Za-z][A-Za-z0-9_]*'
                name: 'meta.identifier.stan'
              }
            ]
        end: '(?<=\\))'
        name: 'meta.distribution-call.stan'
        patterns: [
          {
            include: '#arguments'
          }
        ]
      }
    ]
  'sampling-statement':
    patterns: [
      {
        name: 'meta.sampling.statement.stan'
        begin: '~'
        beginCaptures:
          '0':
            name: 'keyword.operator.sampling.stan'
        end: ';'
        endCaptures:
          '0':
            name: 'punctuation.terminator.statement.stan'
        patterns: [
          {
            'include': '#distribution_calls'
          }
          {
            'include': '#truncation'
          }
        ]
      }
    ]
  'print-expressions':
    patterns: [
      {
        include: '#strings'
      }
      {
        include: '#comma'
      }
      {
        include: '#expression'
      }
    ]
  'print-arguments':
    patterns: [
      {
        name: 'meta.section.print-arguments.stan'
        begin: '\\('
        beginCaptures:
          '0':
            name: 'punctuation.definition.print-arguments.begin.round.bracket.stan'
        end: '\\)'
        endCaptures:
          '0':
            name: 'punctuation.definition.print-arguments.end.round.bracket.stan'
        patterns: [
          {
            'include': '#print-expressions'
          }
        ]
      }
    ]
  reject:
    patterns: [
      {
        begin: '\\b(reject)\\s*(?=\\()'
        beginCaptures:
          '1':
            name: 'keyword.other.reject.stan'
        end: '(?<=\\))'
        patterns: [
          {
            include: '#print-arguments'
          }
        ]
      }
    ]
  print:
    patterns: [
      {
        begin: '\\b(print)\\s*(?=\\()'
        beginCaptures:
          '1':
            name: 'keyword.other.print.stan'
        end: '(?<=\\))'
        patterns: [
          {
            include: '#print-arguments'
          }
        ]
      }
    ]
  'block-statement':
    patterns: [
      {
        comment: '{...} Block. This is hard to distinguish from array literal'
        name: 'meta.section.block.stan'
        begin: '\\{'
        beginCaptures:
          '0':
            'name': 'punctuation.section.block.begin.bracket.curly.stan'
        end: '\\}'
        endCaptures:
          '0':
            name: 'punctuation.section.block.end.bracket.curly.stan'
        patterns: [
          {
            include: '#comma'
          }
          {
            include: '#variable-declarations'
          }
          {
            include: '#statements'
          }
        ]
      }
    ]
  'function-parameters':
    patterns: [
      {
        match: '''(?x)
          \\b
          (?:(data)\\s+)?
          (
              (?:int|real|vector|row_vector|matrix)
              (?:\\s*(?:\\[\\s*(?:,\\s*)*\\]))?
          )
          \\s+
          ([A-Za-z][A-Za-z0-9_]*)
          \\b
        '''
        captures:
          '1':
            name: 'storage.modifier.data.stan'
          '2':
            name: 'storage.type.function-param.stan'
          '3':
            name: 'variable.parameter.function.stan'
      }
      {
        include: '#comments'
      }
      {
        include: '#comma'
      }
    ]
  'function-declarations': {
    comment: "Function declaration"
    name: 'meta.function-declaration.stan'
    begin: '''(?x)
    \\b(
      void|
      (?:int|real|vector|row_vector|matrix)(?:\\[\\s*(?:,\\s*)*\\])?
    )
    \\s+
    ([A-Za-z][A-Za-z0-9_]*)
    \\s*
    (\\()
    '''
    beginCaptures:
      '1':
        name: 'storage.type.return.stan'
      '2':
        name: 'entity.name.function.stan'
      '3':
        name: 'punctuation.definition.function-params.begin.bracket.round.stan'
    end: '\\)'
    endCaptures:
      '0':
        name: 'punctuation.definition.function-params.end.bracket.round.stan'
    patterns: [
      {
        include: '#function-parameters'
      }
    ]
  }
  'keywords-control':
    patterns: [
      {
        match: '\\b(for|while|if|else|break|continue)\\b'
        name: 'keyword.control.stan'
      }
    ]
  'keyword-target':
    patterns: [
      {
        match: '\\b(target\\s*\\+=)'
        name: 'keyword.other.keyword-target.stan'
      }
    ]
  'for-statement':
    patterns: [
      begin: '\\b(for)\\s*(\\()\\s*([A-Za-z][A-Za-z0-9_]*)\\s*(in)\\b'
      beginCaptures:
        '1':
          name: 'keyword.control.stan'
        '2':
          name: 'punctuation.definition.for.begin.round.bracket.stan'
        '3':
          name: 'entity.name.variable.stan'
        '4':
          name: 'keyword.control.stan'
      end: "\\)"
      endCaptures:
        '0':
          name: 'punctuation.definition.for.end.round.bracket.stan'
      patterns: [
        {
          'include': '#colon'
        }
        {
          'include': '#expression'
        }
      ]
      name: 'meta.for.statement.stan'
    ]
  'if-statement':
    patterns: [
      begin: '\\b(if)\\s*(\\()'
      beginCaptures:
        '1':
          name: 'keyword.control.stan'
        '2':
          name: 'punctuation.definition.if.begin.round.bracket.stan'
      end: "\\)"
      endCaptures:
        '0':
          name: 'punctuation.definition.if.end.round.bracket.stan'
      patterns: [
        {
          'include': '#expression'
        }
      ]
      name: 'meta.if.statement.stan'
    ]
  'while-statement':
    patterns: [
      begin: '\\b(while)\\s*(\\()'
      beginCaptures:
        '1':
          name: 'keyword.control.stan'
        '2':
          name: 'punctuation.definition.while.begin.round.bracket.stan'
      end: "\\)"
      endCaptures:
        '0':
          name: 'punctuation.definition.while.end.round.bracket.stan'
      patterns: [
        {
          'include': '#expression'
        }
      ]
      name: 'meta.while.statement.stan'
    ]

  statements:
    patterns: [
      {
        include: '#comment'
      }
      {
        include: '#semicolon'
      }
      {
        include: '#keyword-target'
      }
      {
        include: '#sampling-statement'
      }
      {
        include: '#for-statement'
      }
      {
        include: '#if-statement'
      }
      {
        include: '#while-statement'
      }
      {
        include: '#block-statement'
      }
      {
        include: '#assignment-operators'
      }
      {
        include: '#keywords-control'
      }
      {
        include: '#print'
      }
      {
        include: '#reject'
      }
      {
        include: '#expression'
      }
    ]
  'variable-declaration-assignment-rhs':
    patterns: [
      comment: 'Right hand side of assignment of variable in a declaration statement'
      name: 'meta.section.assignment-rhs.stan'
      begin: '='
      beginCaptures:
        '0':
          name: 'keyword.assignment.stan'
      end: '(?=;)'
      patterns: [
        {
          'include': '#expression'
        }
      ]
    ]
  'range-constraints':
    begin: '<'
    beginCaptures:
      '0':
        name: 'punctuation.definition.range-constraints.begin.angle.bracket.stan'
    end: '>'
    endCaptures:
      '0':
        name: 'punctuation.definition.range-constraints.end.angle.bracket.stan'
    name: 'meta.range-constraints.stan'
    patterns: [
      {
        match: '(lower)\\s*(=)',
        captures:
          '1':
            name: 'keyword.other.range.stan'
          '2':
            name: 'punctuation.delimiter.equals.stan'
      }
      {
        match: '(upper)\\s*(=)',
        captures:
          '1':
            name: 'keyword.other.range.stan'
          '2':
            name: 'punctuation.delimiter.equals.stan'
      }
      {
        'include': '#comma'
      }
      {
        'include': '#expression-base'
      }
    ]
  'variable-declarations':
    patterns: [
      {
        comment: 'Variable declaration'
        name: 'meta.variable-declaration.stan'
        begin: '''(?x)
          \\b(
            int|real|vector|simplex|unit_vector|ordered|positive_ordered|
            row_vector|matrix|corr_matrix|cov_matrix|cholesky_factor_cov|
            cholesky_factor_corr
          )\\b
          '''
        beginCaptures:
          '0':
            name: 'storage.type.stan'
        # after identifier either ; to end statement, [...] for array dims or
        # = for assignment
        end: ';'
        endCaptures:
          '0':
            name: 'punctuation.terminator.statement.stan'
        patterns: [
          {
            'include': '#range-constraints'
          }
          {
            'include': '#brackets'
          }
          {
            'include': '#variable-declaration-assignment-rhs'
          }
          {
            comment: '''If it's not the type declaration and not in
            angled or square brackets, it must be the variable declaration.
            '''
            match: '\\b([A-Za-z][A-Za-z0-9_]*)(?=\\s*[\\[;=])'
            captures:
              '1':
                name: 'entity.name.variable.stan'
          }
        ]
      }
    ]
  functions:
    patterns: [
      {
        comment: 'Function block'
        name: 'meta.section.functions.stan'
        begin: '\\b(functions)\\s*(\\{)'
        beginCaptures:
          '1':
            name: 'entity.name.section.functions.stan'
          '2':
            name: 'punctuation.definition.functions.begin.bracket.curly.stan'
        end: '\\}'
        endCaptures:
          '0':
            name: 'punctuation.definition.functions.end.bracket.curly.stan'
        patterns: [
          {
            include: '#comments'
          }
          {
            include: '#function-declarations'
          }
          {
            comment: '''
              Function declarations only include the declaration.
              The statements rule will match syntax in the function definitions.
            '''
            include: '#statements'
          }
        ]
      }
    ]
  data:
    patterns: [
      {
        comment: 'Data block'
        name: 'meta.section.data.stan'
        begin: '\\b(data)\\s*(\\{)'
        beginCaptures:
          '1':
            name: 'entity.name.section.data.stan'
          '2':
            name: 'punctuation.definition.data.begin.bracket.curly.stan'
        end: '\\}'
        endCaptures:
          '0':
            name: 'punctuation.definition.data.end.bracket.curly.stan'
        patterns: [
          {
            'include': '#comments'
          }
          {
            'include': '#variable-declarations'
          }
        ]
      }
    ]
  transformed_data:
    patterns: [
      {
        comment: 'Transformed data block'
        name: 'meta.section.transformed-data.stan'
        begin: '\\b(transformed\\s+data)\\s*(\\{)'
        beginCaptures:
          '1':
            name: 'entity.name.section.transformed-data.stan'
          '2':
            name: 'punctuation.definition.transformed-data.begin.bracket.curly.stan'
        end: '\\}'
        endCaptures:
          '0':
            name: 'punctuation.definition.transformed-data.end.bracket.curly.stan'
        patterns: [
          {
            'include': '#comments'
          }
          {
            'include': '#variable-declarations'
          }
          {
            'include': '#statements'
          }
        ]
      }
    ]
  parameters:
    patterns: [
      {
        comment: 'Parameters block'
        name: 'meta.section.parameters.stan'
        begin: '\\b(parameters)\\s*(\\{)'
        beginCaptures:
          '1':
            name: 'entity.name.section.parameters.stan'
          '2':
            name: 'punctuation.definition.parameters.begin.bracket.curly.stan'
        end: '\\}'
        endCaptures:
          '0':
            name: 'punctuation.definition.parameters.end.bracket.curly.stan'
        patterns: [
          {
            'include': '#comments'
          }
          {
            'include': '#variable-declarations'
          }
        ]
      }
    ]
  transformed_parameters:
    patterns: [
      {
        comment: 'Transformed parameters block'
        name: 'meta.section.transformed-parameters.stan'
        begin: '\\b(transformed\\s+parameters)\\s*(\\{)'
        beginCaptures:
          '1':
            name: 'entity.name.section.transformed-parameters.stan'
          '2':
            name: 'punctuation.definition.transformed-parameters.begin.bracket.curly.stan'
        end: '\\}'
        endCaptures:
          '0':
            name: 'punctuation.definition.transformed-parameters.end.bracket.curly.stan'
        patterns: [
          {
            'include': '#variable-declarations'
          }
          {
            'include': '#statements'
          }
        ]
      }
    ]
  model:
    patterns: [
      {
        comment: 'Model block'
        name: 'meta.section.model.stan'
        begin: '\\b(model)\\s*(\\{)'
        beginCaptures:
          '1':
            name: 'entity.name.section.model.stan'
          '2':
            name: 'punctuation.definition.model.begin.bracket.curly.stan'
        end: '\\}'
        endCaptures:
          '0':
            name: 'punctuation.definition.model.end.bracket.curly.stan'
        patterns: [
          {
            'include': '#variable-declarations'
          }
          {
            'include': '#statements'
          }
        ]
      }
    ]
  generated_quantities:
    patterns: [
      {
        comment: 'Generated quantities block'
        name: 'meta.section.generated-quantities.stan'
        begin: '\\b(generated\\s+quantities)\\s*(\\{)'
        beginCaptures:
          '1':
            name: 'entity.name.section.generated-quantities.stan'
          '2':
            name: 'punctuation.definition.generated-quantities.begin.bracket.curly.stan'
        end: '\\}'
        endCaptures:
          '0':
            name: 'punctuation.definition.generated-quantities.end.bracket.curly.stan'
        patterns: [
          {
            'include': '#statements'
          }
        ]
      }
    ]
  program:
    patterns: [
      {
        include: '#functions'
      }
      {
        include: '#data'
      }
      {
        include: '#transformed_data'
      }
      {
        include: '#parameters'
      }
      {
        include: '#transformed_parameters'
      }
      {
        include: '#model'
      }
      {
        include: '#generated_quantities'
      }
    ]
